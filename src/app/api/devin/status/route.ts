import { NextRequest, NextResponse } from "next/server";
import { createDevinClient } from "@/lib/devin";
import { getSessionById, updateSession } from "@/lib/storage";
import { createGitHubClient } from "@/lib/github";

export const dynamic = "force-dynamic";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const sessionId = searchParams.get("session_id");

    if (!sessionId) {
      return NextResponse.json(
        { error: "Missing session_id parameter" },
        { status: 400 }
      );
    }

    const session = await getSessionById(sessionId);
    if (!session) {
      return NextResponse.json(
        { error: "Session not found" },
        { status: 404 }
      );
    }

    const devinClient = createDevinClient();
    if (!devinClient) {
      return NextResponse.json(
        { error: "Devin API key not configured" },
        { status: 500 }
      );
    }

    const isScoping = session.status === "scoping";
    const isFixing = session.status === "fixing";
    const devinSessionId = isScoping
      ? session.devin_session_id
      : session.fix_session_id;

    if (!devinSessionId) {
      return NextResponse.json(
        { error: "No active Devin session found" },
        { status: 400 }
      );
    }

    const devinStatus = await devinClient.getSessionStatus(devinSessionId);

    let updatedSession = session;
    // We consider it "finished" if the enum is 'finished' or if the session is no longer 'working' 
    // and we have a result.
    const isWorking =
      devinStatus.status_enum === "working" ||
      devinStatus.status_enum === "resumed" ||
      devinStatus.status_enum?.includes("requested");
    const isFinished = devinStatus.status_enum === "finished" || (!isWorking && devinStatus.status_enum !== null);

    if (isScoping) {
      const scopingResult = devinClient.parseScopingResult(
        devinStatus.structured_output
      );
      if (scopingResult) {
        // If we just finished scoping and haven't posted a comment yet, do it now
        if (isFinished && !session.comment_posted) {
          try {
            const githubClient = createGitHubClient();
            const actionPlanText = scopingResult.action_plan
              .map((item) => `${item.step}. [${item.type}] ${item.description}`)
              .join("\n");
            
            const commentBody = `## Devin Scoping Analysis for #${session.issue_number}

**Summary:** ${scopingResult.summary}

**Confidence Score:** ${scopingResult.confidence_score}%
**Complexity:** ${scopingResult.complexity}
**Estimated Time:** ${scopingResult.estimated_time}

### Action Plan
${actionPlanText}

**Files to Modify:**
${scopingResult.files_to_modify.map(f => `- ${f}`).join("\n") || "To be determined"}

**Potential Risks:**
${scopingResult.potential_risks.map(r => `- ${r}`).join("\n") || "None identified"}

---
*Generated by Devin Integration*`;

            await githubClient.addIssueComment(
              session.repo_owner,
              session.repo_name,
              session.issue_number,
              commentBody
            );
            
            // Mark as comment posted
            updatedSession = await updateSession(session.id, {
              status: "scoped",
              scoping_result: scopingResult,
              comment_posted: true,
            }) || session;
          } catch (githubError) {
            console.error("Failed to post GitHub comment:", githubError);
            // Still update the session status even if comment fails
            updatedSession = await updateSession(session.id, {
              status: "scoped",
              scoping_result: scopingResult,
            }) || session;
          }
        } else {
          updatedSession =
            await updateSession(session.id, {
              status: isFinished ? "scoped" : "scoping",
              scoping_result: scopingResult,
            }) || session;
        }
      } else if (isFinished) {
        updatedSession =
          await updateSession(session.id, {
            status: "scoped",
          }) || session;
      }
    } else if (isFixing) {
      const fixResult = devinClient.parseFixResult(
        devinStatus.structured_output
      );

      if (fixResult) {
        // If Devin created a PR, update the fix result with it
        if (devinStatus.pull_request?.url) {
          fixResult.pr_url = devinStatus.pull_request.url;
        }

        updatedSession =
          await updateSession(session.id, {
            status: isFinished ? "fixed" : "fixing",
            fix_result: fixResult,
          }) || session;
      } else if (isFinished) {
        updatedSession =
          await updateSession(session.id, {
            status: "fixed",
          }) || session;
      }
    }

    if (
      !isFinished &&
      (devinStatus.status_enum === "expired" || devinStatus.status === "failed")
    ) {
      updatedSession =
        await updateSession(session.id, {
          status: "failed",
        }) || session;
    }

    return NextResponse.json({
      session: updatedSession,
      devin_status: devinStatus.status,
      devin_status_enum: devinStatus.status_enum,
      structured_output: devinStatus.structured_output,
    });
  } catch (error) {
    return NextResponse.json(
      { error: `Failed to get session status: ${error}` },
      { status: 500 }
    );
  }
}
